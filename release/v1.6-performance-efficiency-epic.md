# v1.6 Epic - Performance and Efficiency Core

Date: 2026-02-17  
Release: `v1.6`  
Status: Planned

## Problem

The current runtime still pays avoidable latency and reliability costs in the autonomous critical path:

1. Blocking LLM round-trips gate execution where deterministic policy already exists.
2. Market/account reads are too sequential and repeated within the same cycle.
3. Retry/error loops generate noisy failures instead of fast deterministic outcomes.
4. There is no strict release budget enforcing latency/error improvements.

## Epic Goal

Make Thufir materially faster and more deterministic in autonomous operation by moving non-essential LLM work off the hot path, caching market state, triggering scans on events, and enforcing measurable performance SLOs.

## Product Contract

1. Execution-critical decisions are deterministic and policy-gated.
2. LLM remains available for enrichment/rationale, but cannot block critical execution paths.
3. Runtime uses shared cached market snapshots for scan cycles unless stale thresholds are exceeded.
4. Scan loops can be timer-driven and event-driven, with dedupe/cooldown protections.
5. Every release candidate must pass explicit latency/error budgets.

## Architecture Plan

## 1) Autonomous Hot-Path Simplification

1. Remove LLM-based expression selection from execution gate.
2. Keep LLM thesis/context generation as async enrichment artifact.
3. Ensure audit traces show deterministic policy reasons for selections.

Acceptance criterion:
Autonomous execution no longer waits on selection LLM call.

Test requirement:
Unit and integration tests proving mechanical selection path with/without LLM availability.

## 2) Market Data Cache and Snapshot Reuse

1. Build `MarketDataCache` with configurable refresh cadence.
2. Cache static metadata (market specs) separately from fast-changing fields.
3. Provide cycle-level immutable snapshot read API for scan/monitor code.

Acceptance criterion:
A full scan cycle reads market state from cache snapshot, not N sequential API calls.

Test requirement:
Cache refresh/staleness tests and integration tests validating snapshot reuse per cycle.

## 3) Event-Driven Scan Triggering

1. Add trigger sources: high-impact intel event and market anomaly event.
2. Coalesce duplicate events into bounded trigger windows.
3. Keep existing interval scan as fallback safety loop.

Acceptance criterion:
High-impact event can start a scan immediately without waiting for next timer tick.

Test requirement:
Trigger dedupe/cooldown tests and integration test validating immediate scan dispatch.

## 4) Execution Reliability Hardening

1. Normalize/validate order payloads before tool invocation.
2. Add explicit retry policy by error class (retryable vs terminal).
3. Prevent repeated attempts for known-invalid combinations in same cycle.

Acceptance criterion:
Invalid input errors are surfaced once with deterministic reason, not repeated blindly.

Test requirement:
Table-driven tests for retry classifier and payload validation.

## 5) Quote/Orderbook Freshness for IOC

1. Add best-bid/ask path (stream or fastest available source) for execution price anchoring.
2. Introduce max quote age budget before IOC submit.
3. Fallback to safe abort/reprice when quote freshness fails.

Acceptance criterion:
IOC submissions use quotes within configured freshness bounds.

Test requirement:
Execution tests for fresh vs stale quote handling and fallback behavior.

## 6) Async Enrichment Pipeline

1. Split post-decision enrichment into async pipeline stage.
2. Attach enrichment results to journal/notification artifacts when available.
3. Enforce enrichment timeout budgets so execution path remains non-blocking.

Acceptance criterion:
Order path can complete even when enrichment LLM times out.

Test requirement:
Fault-injection tests with LLM timeout/failure proving non-blocking execution.

## 7) Performance Telemetry and Budgets

1. Add per-stage timers for scan pipeline and execution pipeline.
2. Track metrics: p50/p95 scan duration, API calls per cycle, order error rates, stale-data incidents.
3. Define v1.6 release budgets with pass/fail thresholds.

Acceptance criterion:
Release validation report shows all required budget checks pass.

Test requirement:
Benchmark harness and CI assertions on telemetry snapshots.

## 8) Release Performance Acceptance Suite

1. Add deterministic scenario runner for representative autonomous cycles.
2. Compare baseline (v1.5) vs candidate (v1.6) on latency/error metrics.
3. Gate release promotion when regressions exceed allowed budget.

Acceptance criterion:
`release/v1.6` passes full performance acceptance checks before merge to `develop`.

Test requirement:
Automated acceptance workflow with artifact output and threshold assertions.

## Exit Criteria

1. Critical path LLM selection gate removed and covered by tests.
2. Cache/snapshot model is active in autonomous scan loop.
3. Event-driven triggers work with dedupe/cooldown guarantees.
4. Execution retry noise is reduced through deterministic validation/classification.
5. Performance budget checks are part of release validation and green.
