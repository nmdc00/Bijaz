# v1.5 Implementation Sketch - Web Search Provider Resilience

Date: 2026-02-17  
Status: Design Sketch (no code)

## Goal

Implement OpenClaw-style resilient web search so Thufir does not fail hard when one provider is exhausted or degraded.

Core outcomes:

- Provider fallback chain (`primary -> secondary -> tertiary`)
- Shared cache with TTL and deterministic query keys
- Budget controls and circuit breakers
- Clear provenance + telemetry for every search result

## Target Behavior

1. `web_search` receives query + constraints.
2. Check cache first. On hit, return cached results and usage metadata.
3. On cache miss, call provider chain in configured order.
4. If provider fails with retriable class (quota/rate-limit/timeout/5xx), try next provider.
5. If provider fails with non-retriable class (auth/config), mark provider unhealthy and continue to next.
6. Persist telemetry: chosen provider, attempts, failure class, latency, cache status.
7. Return normalized response shape with `as_of`, provider used, and source list.

## Proposed Modules

- `src/intel/web_search/providers/`
- `src/intel/web_search/providers/brave.ts`
- `src/intel/web_search/providers/perplexity.ts`
- `src/intel/web_search/providers/serpapi.ts`
- `src/intel/web_search/orchestrator.ts` (fallback + budgets + breaker)
- `src/intel/web_search/cache.ts` (TTL cache + key normalization)
- `src/intel/web_search/types.ts`
- `src/intel/web_search/errors.ts` (error classification)

## Config Sketch

```yaml
intel:
  webSearch:
    enabled: true
    providers:
      order: [brave, perplexity, serpapi]
      brave:
        enabled: true
        apiKey: ${BRAVE_API_KEY}
      perplexity:
        enabled: false
        apiKey: ${PERPLEXITY_API_KEY}
      serpapi:
        enabled: true
        apiKey: ${SERPAPI_KEY}
    cache:
      enabled: true
      ttlSeconds: 900
      maxEntries: 5000
    budgets:
      maxQueriesPerTurn: 5
      maxQueriesPerDay: 500
      perProviderDailyCaps:
        brave: 300
        perplexity: 100
        serpapi: 100
    circuitBreaker:
      failureThreshold: 5
      openSeconds: 300
```

## Normalized Result Contract

```json
{
  "as_of": "2026-02-17T11:30:00.000Z",
  "query": "btc funding regime",
  "provider_used": "brave",
  "cache": { "hit": false, "key": "..." },
  "attempts": [
    { "provider": "brave", "status": "ok", "latency_ms": 421 }
  ],
  "results": [
    { "title": "...", "url": "...", "snippet": "...", "source": "...", "published_at": "..." }
  ]
}
```

## Error Classification

Retriable (fallback to next provider):

- `quota_exhausted`
- `rate_limited`
- `timeout`
- `provider_5xx`
- `network_error`

Non-retriable (mark provider unhealthy, continue if others exist):

- `invalid_api_key`
- `provider_misconfigured`
- `unsupported_request`

Fail-closed terminal:

- No providers configured/enabled
- All providers failed and no cached result available

## Rollout Plan

1. Add provider interface + orchestrator scaffold.
2. Implement Brave adapter (primary path).
3. Implement Perplexity + SerpApi adapters.
4. Add cache + budget + breaker controls.
5. Wire into existing `web_search` tool path.
6. Add telemetry + dashboard/ops summary.
7. Run staged rollout with primary-only, then fallback enabled.

## Test Plan

Unit tests:

- fallback order selection
- failure classification mapping
- cache key normalization + TTL behavior
- budget cap enforcement
- circuit breaker open/half-open/closed transitions

Integration tests:

- primary quota exhaustion -> secondary success
- repeated query -> cache hit path
- all providers unavailable -> deterministic fail-closed response
- provenance fields present in returned result

Acceptance checks:

- No hard failure when monthly SerpApi quota is exhausted and fallback exists.
- Search latency remains bounded under fallback scenarios.
- Daily query spend stays within configured caps.
