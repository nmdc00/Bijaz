# v1.5 Epic - Autonomous Outbound Worker Loop

Date: 2026-02-17  
Release: `v1.5`  
Status: Planned

## Problem

Thufir can process chat messages reliably and has scheduler components, but autonomous outbound behavior is not yet productized as a first-class, always-on operator loop with deterministic triggers and resilient delivery.

## Epic Goal

Build a dedicated background worker loop so Thufir can detect conditions and notify the operator without user interaction.

## Mandatory Safety/Quality Additions (From v1.4 Gaps)

1. Add a daily drawdown hard gate to autonomous pre-trade evaluation.
2. Unify session-weight implementations across autonomous and mentat paths.
3. Replace `/delphi` placeholder scoring with real signal-derived prediction inputs.
4. Prove context-pack effect on decision quality with explicit measurement.
5. Add mechanical post-trade component labeling (direction/timing/sizing/exit).
6. Add an operator-grade single-message `/status` surface for background trust.

## Product Contract

1. The worker runs continuously as a service and is independent from inbound chat.
2. Trigger decisions are mechanical (policy/rules), not dependent on LLM availability.
3. LLM is enrichment-only: summary, rationale, recommended next action.
4. Outbound notifications support severity routing, dedupe, and cooldown.
5. Every alert has traceable lifecycle state in storage (`open`, `suppressed`, `sent`, `resolved`).

## Architecture Plan

## 1) Separate Worker Service

1. Introduce a dedicated process entrypoint (`thufir worker alerts` or equivalent).
2. Run under systemd with `Restart=always`.
3. Isolate worker logs/metrics from chat gateway logs.

Acceptance criterion:
Worker remains active through gateway restarts and chat inactivity.

Test requirement:
Service-level integration test for startup, restart, and graceful shutdown.

## 2) Trigger Engine (Mechanical Core)

1. Implement deterministic triggers for:
- Account equity move over configured window.
- Position ROE thresholds (profit and loss).
- Liquidation distance threshold.
- Exposure delta threshold after auto-execution.
2. Evaluate on interval and optional event inputs.
3. Emit structured trigger artifacts with stable IDs.

Acceptance criterion:
Each trigger type fires deterministically from fixture inputs.

Test requirement:
Table-driven unit tests for threshold crossing and reset behavior.

## 3) Notification Policy Layer

1. Add dedupe keys and cooldown windows per trigger class.
2. Add severity classes (`info`, `warning`, `critical`) with channel routing.
3. Add suppression reason codes for blocked sends.

Acceptance criterion:
Repeated identical events within cooldown produce one send and N suppressions.

Test requirement:
Policy tests for dedupe, cooldown expiry, and severity routing.

## 4) Delivery Adapters

1. Reuse Telegram adapter first; keep interface for Discord/email/webhook.
2. Add delivery retry policy with bounded attempts.
3. Persist send outcomes (`sent`, `failed`, `retrying`) for observability.

Acceptance criterion:
Adapter retries transient failures and records terminal status.

Test requirement:
Adapter tests with simulated 429/5xx and eventual success/failure.

## 5) LLM Enrichment (Optional, Non-Blocking)

1. After trigger passes policy, call LLM for concise narrative.
2. Enforce strict per-alert timeout budget.
3. On timeout/failure, send mechanical fallback summary.

Acceptance criterion:
Critical alerts are still delivered when LLM is unavailable.

Test requirement:
Fault-injection tests proving fallback send path.

## 6) Persistence and Incident Lifecycle

1. Add alert incident tables (`alerts`, `alert_events`, `alert_deliveries`).
2. Track state transitions and timestamps.
3. Support acknowledgment and resolution hooks.

Acceptance criterion:
Every outbound alert has an auditable record from trigger to delivery result.

Test requirement:
Migration + lifecycle integration tests.

## 7) Runtime Configuration

1. Add `notifications.worker` config block:
- `enabled`
- `intervalSeconds`
- `channels`
- `trigger thresholds`
- `dedupe/cooldown`
- `llm enrichment timeout`
2. Validate config schema and safe defaults.

Acceptance criterion:
Misconfigured worker settings fail closed with clear startup errors.

Test requirement:
Config validation tests and startup error-path tests.

## 8) Daily Drawdown Hard Gate

1. Add drawdown threshold config in autonomy policy.
2. Evaluate daily realized/unrealized P&L before new execution using `getDailyPnLRollup` inside `evaluateGlobalTradeGate`.
3. Block all new non-reduce-only entries once breached.

Acceptance criterion:
No new autonomous entry orders are placed after drawdown cap breach.

Test requirement:
Policy tests for below-threshold, exact-threshold, and breached-threshold states.

## 9) Session Weighting Consolidation

1. Move session weighting into shared module used by all decision surfaces.
2. Remove duplicated weighting logic in mode-specific paths.
3. Add a single reference test matrix for UTC/session boundaries.

Acceptance criterion:
Autonomous and mentat produce identical session weights for same timestamp/input.

Test requirement:
Cross-module parity tests against shared fixtures.

## 10) Delphi Real-Signal Integration

1. Replace placeholder symbol-code heuristics with actual market/signal features.
2. Keep `/delphi` non-executing by default until calibration thresholds pass.
3. Mark preview-only mode as experimental fallback, not default.

Acceptance criterion:
Delphi predictions vary with market state changes, not ticker string artifacts.

Test requirement:
Fixture tests showing prediction deltas for changed signal inputs on same symbol.

## 11) Context-Pack Effectiveness Verification

1. Ensure context pack is consumed in reasoning/selection prompts where intended.
2. Add offline A/B evaluation path (with/without context pack).
3. Track calibration/decision-quality delta before declaring production value.

Acceptance criterion:
Context pack shows non-trivial improvement in at least one quality metric.

Test requirement:
Evaluation tests + report artifact comparing baseline vs context-pack enabled runs.

## 12) Mechanical Decision Component Labeling

1. Extend trade journal schema for per-trade component scores:
- `direction_score`
- `timing_score`
- `sizing_score`
- `exit_score`
2. Compute labels mechanically at close from market/trade path data (no LLM dependency).
3. Define deterministic formulas and bounds for each component score.

Acceptance criterion:
Every closed autonomous trade has all four component scores persisted.

Test requirement:
Deterministic scoring tests from fixture trades with expected component outputs.

## 13) `/status` Operator Snapshot Command

1. Add `/status` command returning one concise message for operator visibility.
2. Include fields:
- equity
- open positions with P&L
- policy state
- last trade outcome
- next scan time
- uptime
- daily P&L
3. Ensure Telegram-friendly formatting and bounded message size.

Acceptance criterion:
Single `/status` call yields complete runtime + risk snapshot in one message.

Test requirement:
Command integration test validating required fields and formatting constraints.

## Sprint Task/Branch Plan

1. `feat/v1.5-worker-service-entrypoint`
2. `feat/v1.5-trigger-engine-core`
3. `feat/v1.5-notification-policy-dedupe-cooldown`
4. `feat/v1.5-alert-delivery-adapters`
5. `feat/v1.5-llm-enrichment-fallback`
6. `feat/v1.5-alert-persistence-lifecycle`
7. `feat/v1.5-worker-config-schema`
8. `feat/v1.5-drawdown-hard-gate`
9. `feat/v1.5-session-weight-consolidation`
10. `feat/v1.5-delphi-real-signal-integration`
11. `feat/v1.5-context-pack-effectiveness-eval`
12. `feat/v1.5-decision-component-labeling`
13. `feat/v1.5-status-command-snapshot`
14. `feat/v1.5-worker-e2e-acceptance`

## Merge Order

1. Service entrypoint
2. Trigger engine
3. Policy layer
4. Delivery adapters
5. Persistence lifecycle
6. Config schema
7. Drawdown hard gate
8. Session-weight consolidation
9. Delphi real-signal integration
10. Context-pack effectiveness eval
11. Decision component labeling
12. Status command snapshot
13. LLM enrichment fallback
14. E2E acceptance

## Exit Criteria

1. Worker service runs in production mode without chat traffic.
2. At least four trigger classes are active with deterministic tests.
3. Alert dedupe/cooldown prevents spam in stress simulation.
4. LLM outage simulation still produces critical outbound alerts.
5. Daily drawdown hard gate blocks autonomous entries when breached.
6. Session-weight logic is unified with cross-module parity tests.
7. Delphi uses real signals; placeholder scoring path is not default.
8. Context-pack effect is measured and documented with evaluation output.
9. Closed trades include direction/timing/sizing/exit component scores.
10. `/status` delivers one-message operator snapshot with required fields.
11. End-to-end acceptance suite is green on `release/v1.5`.
